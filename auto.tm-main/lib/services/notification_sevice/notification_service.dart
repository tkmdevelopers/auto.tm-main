import 'dart:convert';
import 'package:auto_tm/firebase_options.dart';
import 'package:auto_tm/utils/key.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';
import 'package:http/http.dart' as http;

class NotificationService extends GetxService {
  late final FirebaseMessaging _firebaseMessaging;
  final FlutterLocalNotificationsPlugin _localNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
  final GetStorage _storage = GetStorage();
  final String _globalTopicKey = 'isSubscribedToGlobalTopic';
  final bool debug = false;

  Future<void> init() async {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    _firebaseMessaging = FirebaseMessaging.instance;
    await _initializeLocalNotifications();
  }

  Future<void> enableNotifications() async {
    await _requestPermissions();
    _setupForegroundHandler();
    _setupBackgroundHandler();
    _setupTokenRefreshListener();
    await _sendDeviceTokenToBackend();

    final isSubscribed = _storage.read<bool>(_globalTopicKey) ?? false;
    final accessToken = _storage.read('ACCESS_TOKEN');
    if (!isSubscribed && accessToken != null) {
      await subscribeToGlobalTopic();
    }
  }

  Future<void> subscribeToGlobalTopic({String topic = 'all'}) async {
    try {
      await _firebaseMessaging.subscribeToTopic(topic);
      await _storage.write(_globalTopicKey, true);
      _log("Subscribed to topic: $topic");
    } catch (e) {
      _log("Error subscribing to topic: $e");
    }
  }

  Future<void> _requestPermissions() async {
    final settings = await _firebaseMessaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );
    _log("User granted permission: ${settings.authorizationStatus}");
  }

  Future<void> _sendDeviceTokenToBackend() async {
    try {
      final token = await _firebaseMessaging.getToken();
      if (token == null) {
        _log("Failed to get FCM token.");
        return;
      }

      await _storage.write('FCM_TOKEN', token);
      await _uploadToken(token);
    } catch (e) {
      _log("Error fetching/sending token: $e");
    }
  }

  Future<void> _uploadToken(String token) async {
    final accessToken = _storage.read('ACCESS_TOKEN');
    if (accessToken == null) {
      _log("No access token found. Cannot send FCM token.");
      return;
    }

    try {
      final response = await http.put(
        Uri.parse(ApiKey.setFirebaseKey),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $accessToken',
        },
        body: jsonEncode({'token': token}),
      );

      if (response.statusCode == 200) {
        _log("Token sent to backend successfully.");
      } else {
        _log(
          "Backend rejected token: ${response.statusCode} - ${response.body}",
        );
      }
    } catch (e) {
      _log("Error sending token to backend: $e");
    }
  }

  void _setupTokenRefreshListener() {
    _firebaseMessaging.onTokenRefresh.listen((newToken) async {
      _log("Token refreshed: $newToken");
      await _uploadToken(newToken);
      await _storage.write('FCM_TOKEN', newToken);
    });
  }

  void _setupForegroundHandler() {
    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      if (message.notification != null) {
        _showNotification(message);
      }
    });
  }

  void _setupBackgroundHandler() {
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
  }

  @pragma('vm:entry-point')
  static Future<void> _firebaseMessagingBackgroundHandler(
    RemoteMessage message,
  ) async {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    final service = NotificationService();
    service._showNotification(message);
  }

  Future<void> _initializeLocalNotifications() async {
    // Use a safer default icon. The previous 'ic_launcher_foreground' caused
    // PlatformException(invalid_icon, resource ... not found) on some builds
    // when the adaptive foreground asset wasn't present in the merged manifest.
    // Fallback to 'ic_launcher' (generated by Flutter template). If you add a
    // custom monochrome notification icon later (e.g. res/drawable/ic_stat_app.png),
    // replace below with that resource name.
    const AndroidInitializationSettings androidSettings =
        AndroidInitializationSettings('ic_launcher');
    const iosSettings = DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );

    const initSettings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );

    try {
      await _localNotificationsPlugin.initialize(initSettings);
      _log("Local notifications initialized.");
    } catch (e) {
      _log("Local notifications init failed: $e");
    }
  }

  void _showNotification(RemoteMessage message) async {
    final notification = message.notification;
    final android = notification?.android;
    final ios = notification?.apple;

    if (notification == null) return;

    const androidDetails = AndroidNotificationDetails(
      'channel_id',
      'channel_name',
      channelDescription: 'channel_description',
      importance: Importance.max,
      priority: Priority.high,
    );

    const iosDetails = DarwinNotificationDetails(
      presentAlert: true,
      presentBadge: true,
      presentSound: true,
    );

    final notificationDetails = NotificationDetails(
      android: android != null ? androidDetails : null,
      iOS: ios != null ? iosDetails : null,
    );

    await _localNotificationsPlugin.show(
      notification.hashCode,
      notification.title,
      notification.body,
      notificationDetails,
      payload: jsonEncode(message.data),
    );
  }

  Future<void> sendTokenToBackend(String token) async {
    await _uploadToken(token);
  }

  void _log(String message) {
    if (kDebugMode) {
      print("[NotificationService] $message");
    }
  }
}
